shader scratchSh (
	float Cin=1,
	float frequency=10,
	float range=1,
	float mag=0,
	float thickness=0.1,
	output float Cout=1
	)
{
    float i;
    float freq=frequency;
	float u1,u2,v1,v2;

	Cout=0.0;
    while(i>range)
	{
	u1=abs((float)noise("perlin",P*freq))/freq/mag;
	v1=abs((float)noise("perlin",P*freq))/freq*range;
	u2=abs((float)noise("perlin",P*freq))/freq/mag;
	v2=abs((float)noise("perlin",P*freq))/freq*range;
	i=((u1-u2)*(u1-u2)+(v1-v2)*(v1-v2))/2;
	}

	float leftPointu,leftPointv;
    float rightPointu,rightPointv;

    // Normalize start/end to left right to make the offset calc simpler.
    if (u1 <= u2)
    {
        leftPointu   = u1;
        rightPointu  = u2;
    }
    else
    {
        leftPointu   = u2;
        rightPointu  = u1;
    }
	int inStripe;
	int y = 0;
	while(y==0)
	{
		float minV,maxV;
		if(leftPointv < rightPointv)
		{
			minV = leftPointv;
		}
		else
		{
			minV = rightPointv;
		}
		if(leftPointv > rightPointv)
		{
			maxV = leftPointv;
		}
		else
		{
			maxV = rightPointv;
		}

		// If point is out of bounds, no need to do further checks.                  
		if (u + thickness < leftPointu || rightPointu < u - thickness)
		{
			inStripe = 0;
			break;
		}
		else if (v + thickness < minV || maxV < v - thickness)
		{
			inStripe = 0;
			break;
		}
		float deltaX = rightPointu - leftPointu;
		float deltaY = rightPointv - leftPointv;

		// If the line is straight, the earlier boundary check is enough to determine that the point is on the line.
		// Also prevents division by zero exceptions.
		if (deltaX == 0 || deltaY == 0)
		{
			inStripe = 1;
			break;
		}

		float slope        = deltaY / deltaX;
		float offset       = leftPointv - leftPointu * slope;
		float calculatedY  = u * slope + offset;

		// Check calculated Y matches the points Y coord with some easing.
		if(v - thickness <= calculatedY && calculatedY <= v + thickness)
		{
			inStripe = 1;
		}
		else
		{
			inStripe = 0;
		}
		break;
	}

	if(inStripe==1)
	{
		Cout=1;
	}
	else
	{
		Cout=Cin;
	}
}

